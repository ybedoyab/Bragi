import {
  require_react
} from "./chunk-XD5MHVJS.js";
import "./chunk-RMBEYMPO.js";
import {
  __commonJS,
  __toESM
} from "./chunk-HM4MQYWN.js";

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React4 = require_react();
        var ReactSharedInternals = React4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState3 = React4.useState, useEffect4 = React4.useEffect, useLayoutEffect2 = React4.useLayoutEffect, useDebugValue = React4.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React4.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState3({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect2(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect4(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
        var useSyncExternalStore$2 = React4.useSyncExternalStore !== void 0 ? React4.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../../node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "../../node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React4 = require_react();
        var shim = require_shim();
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore = shim.useSyncExternalStore;
        var useRef4 = React4.useRef, useEffect4 = React4.useEffect, useMemo = React4.useMemo, useDebugValue = React4.useDebugValue;
        function useSyncExternalStoreWithSelector4(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef4(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
          useEffect4(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue(value);
          return value;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector4;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../../node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "../../node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// ../../node_modules/@connect2ic/react/dist/connect2ic-react.esm.js
var import_react6 = __toESM(require_react());

// ../../node_modules/@xstate/react/es/useMachine.js
var import_react3 = __toESM(require_react());
var import_with_selector = __toESM(require_with_selector());

// ../../node_modules/@xstate/react/es/useInterpret.js
var import_react2 = __toESM(require_react());

// ../../node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var import_react = __toESM(require_react());

// ../../node_modules/@xstate/react/es/useConstant.js
var React = __toESM(require_react());

// ../../node_modules/@xstate/react/es/utils.js
function getServiceSnapshot(service) {
  return service.status !== 0 ? service.getSnapshot() : service.machine.initialState;
}
function isService(actor) {
  return "state" in actor && "machine" in actor;
}

// ../../node_modules/@xstate/react/es/useActor.js
var import_react4 = __toESM(require_react());
var import_with_selector2 = __toESM(require_with_selector());
function isActorWithState(actorRef) {
  return "state" in actorRef;
}

// ../../node_modules/@xstate/react/es/useSelector.js
var import_react5 = __toESM(require_react());
var import_with_selector3 = __toESM(require_with_selector());
var defaultCompare = function(a, b) {
  return a === b;
};
var defaultGetSnapshot = function(a, initialStateCacheRef) {
  if (isService(a)) {
    if (a.status === 0 && initialStateCacheRef.current) {
      return initialStateCacheRef.current;
    }
    var snapshot = getServiceSnapshot(a);
    initialStateCacheRef.current = a.status === 0 ? snapshot : null;
    return snapshot;
  }
  return isActorWithState(a) ? a.state : void 0;
};
function useSelector(actor, selector, compare, getSnapshot) {
  if (compare === void 0) {
    compare = defaultCompare;
  }
  var initialStateCacheRef = (0, import_react5.useRef)(null);
  var subscribe = (0, import_react5.useCallback)(function(handleStoreChange) {
    var unsubscribe = actor.subscribe(handleStoreChange).unsubscribe;
    return unsubscribe;
  }, [actor]);
  var boundGetSnapshot = (0, import_react5.useCallback)(function() {
    if (getSnapshot) {
      return getSnapshot(actor);
    }
    return defaultGetSnapshot(actor, initialStateCacheRef);
  }, [actor, getSnapshot]);
  var selectedSnapshot = (0, import_with_selector3.useSyncExternalStoreWithSelector)(subscribe, boundGetSnapshot, boundGetSnapshot, selector, compare);
  return selectedSnapshot;
}

// ../../node_modules/@xstate/react/es/createActorContext.js
var React2 = __toESM(require_react());

// ../../node_modules/@connect2ic/react/dist/connect2ic-react.esm.js
var Connect2ICContext = (0, import_react6.createContext)({});
var Connect2ICProvider = (_ref) => {
  let {
    children,
    client
  } = _ref;
  const [open, setOpen] = (0, import_react6.useState)(false);
  const dialog = {
    open: () => setOpen(true),
    close: () => setOpen(false),
    isOpen: open
  };
  return import_react6.default.createElement(Connect2ICContext.Provider, {
    value: {
      client,
      dialog
    }
  }, children);
};
var useConnect = (props) => {
  var _client$_service$stat, _client$_service$stat2, _client$_service$stat3, _client$_service$stat4, _client$_service$stat5, _client$_service$stat6, _client$_service$stat7, _client$_service$stat8, _client$_service$stat9, _client$_service$stat10;
  const {
    onConnect = () => {
    },
    onDisconnect = () => {
    }
  } = props !== null && props !== void 0 ? props : {};
  const {
    client
  } = (0, import_react6.useContext)(Connect2ICContext);
  const {
    principal,
    activeProvider,
    status
  } = useSelector(client._service, (state) => ({
    principal: state.context.principal,
    activeProvider: state.context.activeProvider,
    status: state.value.idle
  }));
  (0, import_react6.useEffect)(() => {
    const unsub = client.on("connect", onConnect);
    const unsub2 = client.on("disconnect", onDisconnect);
    return () => {
      unsub();
      unsub2();
    };
  }, [client]);
  return {
    principal,
    activeProvider,
    status,
    isInitializing: (_client$_service$stat = (_client$_service$stat2 = client._service.state) === null || _client$_service$stat2 === void 0 ? void 0 : _client$_service$stat2.matches({
      idle: "initializing"
    })) !== null && _client$_service$stat !== void 0 ? _client$_service$stat : false,
    isConnected: (_client$_service$stat3 = (_client$_service$stat4 = client._service.state) === null || _client$_service$stat4 === void 0 ? void 0 : _client$_service$stat4.matches({
      idle: "connected"
    })) !== null && _client$_service$stat3 !== void 0 ? _client$_service$stat3 : false,
    isConnecting: (_client$_service$stat5 = (_client$_service$stat6 = client._service.state) === null || _client$_service$stat6 === void 0 ? void 0 : _client$_service$stat6.matches({
      idle: "connecting"
    })) !== null && _client$_service$stat5 !== void 0 ? _client$_service$stat5 : false,
    isDisconnecting: (_client$_service$stat7 = (_client$_service$stat8 = client._service.state) === null || _client$_service$stat8 === void 0 ? void 0 : _client$_service$stat8.matches({
      idle: "disconnecting"
    })) !== null && _client$_service$stat7 !== void 0 ? _client$_service$stat7 : false,
    isIdle: (_client$_service$stat9 = (_client$_service$stat10 = client._service.state) === null || _client$_service$stat10 === void 0 ? void 0 : _client$_service$stat10.matches({
      idle: "idle"
    })) !== null && _client$_service$stat9 !== void 0 ? _client$_service$stat9 : false,
    connect: (provider) => {
      client.connect(provider);
    },
    disconnect: () => {
      client.disconnect();
    }
  };
};
var useCanister = function(canisterName) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    mode: "auto"
    // "anonymous" | "connected"
  };
  const {
    mode
  } = options;
  const {
    client
  } = (0, import_react6.useContext)(Connect2ICContext);
  const anonymousActor = useSelector(client._service, (state) => state.context.anonymousActors[canisterName]);
  const actor = useSelector(client._service, (state) => state.context.actors[canisterName]);
  const canisterDefinition = useSelector(client._service, (state) => state.context.canisters[canisterName]);
  const {
    isConnected
  } = useConnect();
  const signedIn = isConnected && actor && mode !== "anonymous";
  const canister = signedIn ? actor : anonymousActor;
  const loading = !canister;
  const error = false;
  return [canister, {
    error,
    loading,
    canisterDefinition
  }];
};
var useWallet = () => {
  const {
    client
  } = (0, import_react6.useContext)(Connect2ICContext);
  const activeProvider = useSelector(client._service, (state) => state.context.activeProvider);
  const supportsWallet = !!(activeProvider !== null && activeProvider !== void 0 && activeProvider.meta.features.includes("wallet"));
  const {
    isConnected
  } = useConnect();
  const wallet = isConnected && supportsWallet ? activeProvider : void 0;
  return [wallet];
};
var useBalance = () => {
  const [wallet] = useWallet();
  const {
    activeProvider
  } = useConnect();
  const [assets, setAssets] = (0, import_react6.useState)();
  const [loading, setLoading] = (0, import_react6.useState)(true);
  const [error, setError] = (0, import_react6.useState)(false);
  const refetch = async () => {
    var _activeProvider$query;
    if (!wallet || !activeProvider) {
      setAssets(void 0);
      return;
    }
    const result = await ((_activeProvider$query = activeProvider.queryBalance) === null || _activeProvider$query === void 0 ? void 0 : _activeProvider$query.call(activeProvider));
    setAssets(result);
    setLoading(false);
    return result;
  };
  (0, import_react6.useEffect)(() => {
    if (!wallet) {
      setAssets(void 0);
      return;
    }
    refetch();
  }, [wallet]);
  return [assets, {
    loading,
    error,
    refetch
  }];
};
var useDialog = function() {
  const {
    dialog
  } = (0, import_react6.useContext)(Connect2ICContext);
  return dialog;
};
var useProviders = () => {
  const {
    client
  } = (0, import_react6.useContext)(Connect2ICContext);
  const providers = useSelector(client._service, (state) => state.context.providers);
  return providers !== null && providers !== void 0 ? providers : [];
};
var useSignMessage = (_ref) => {
  let {
    message
  } = _ref;
  const {
    activeProvider
  } = useConnect();
  const [wallet] = useWallet();
  const signMessage = () => {
    var _activeProvider$signM;
    if (!wallet || !activeProvider) {
      return;
    }
    (_activeProvider$signM = activeProvider.signMessage) === null || _activeProvider$signM === void 0 ? void 0 : _activeProvider$signM.call(activeProvider, {
      message
    });
  };
  const loading = false;
  const error = false;
  return [signMessage, {
    loading,
    error
  }];
};
var useTransfer = (_ref) => {
  let {
    amount,
    to,
    from = void 0
  } = _ref;
  const [wallet] = useWallet();
  const {
    activeProvider,
    principal
  } = useConnect();
  const [loading, setLoading] = (0, import_react6.useState)(false);
  const [error, setError] = (0, import_react6.useState)();
  const transfer = async () => {
    if (!wallet || !activeProvider) {
      return;
    }
    setLoading(true);
    const result = await activeProvider.requestTransfer({
      amount,
      to,
      from: from !== null && from !== void 0 ? from : principal
    }).catch((e) => {
      setError(e);
    });
    setLoading(false);
    return result;
  };
  return [transfer, {
    loading,
    error
  }];
};
var useClient = () => {
  const {
    client
  } = (0, import_react6.useContext)(Connect2ICContext);
  return client;
};
var ConnectButton = (props) => {
  const {
    style = {},
    dark = false,
    onConnect = () => {
    },
    onDisconnect = () => {
    },
    children
  } = props;
  const dialog = useDialog();
  const {
    disconnect,
    isConnected
  } = useConnect({
    onConnect,
    onDisconnect
  });
  return import_react6.default.createElement(import_react6.default.Fragment, null, !isConnected ? import_react6.default.createElement("button", {
    onClick: () => dialog.open(),
    style,
    className: "connect-button"
  }, children !== null && children !== void 0 ? children : "Connect") : null, isConnected ? import_react6.default.createElement("button", {
    onClick: disconnect,
    style,
    className: "connect-button"
  }, children !== null && children !== void 0 ? children : "Disconnect") : null);
};
var ConnectButton$1 = ConnectButton;
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var ConnectDialog = (props) => {
  const {
    onClose = () => {
      dialog.close();
    },
    children,
    dark
  } = props;
  const dialog = useDialog();
  const providers = useProviders();
  const {
    connect,
    isConnected
  } = useConnect();
  (0, import_react6.useEffect)(() => {
    if (isConnected) {
      dialog.close();
    }
  }, [isConnected]);
  (0, import_react6.useEffect)(() => {
    if (dialog.isOpen) {
      document.body.style.overflow = "hidden";
    }
    if (!dialog.isOpen) {
      document.body.style.overflow = "unset";
    }
  }, [dialog.isOpen]);
  (0, import_react6.useEffect)(() => {
    const handleEsc = (event) => {
      if (event.keyCode === 27) {
        dialog.close();
      }
    };
    window.addEventListener("keydown", handleEsc);
    return () => {
      window.removeEventListener("keydown", handleEsc);
    };
  }, []);
  const onClickInside = (e) => {
    e.stopPropagation();
  };
  return dialog.isOpen ? import_react6.default.createElement(import_react6.default.Fragment, null, import_react6.default.createElement("div", {
    className: "dialog-styles ".concat(dark ? "dark" : "light"),
    onClick: onClose
  }, import_react6.default.createElement("div", {
    onClick: onClickInside,
    className: "dialog-container"
  }, import_react6.default.createElement("div", null, providers.map((provider) => {
    return import_react6.default.createElement("button", _extends({
      key: provider.meta.id,
      onClick: () => connect(provider.meta.id),
      className: "button-styles ".concat(provider.meta.id, "-styles")
    }, props), import_react6.default.createElement("img", {
      className: "img-styles",
      src: dark ? provider.meta.icon.dark : provider.meta.icon.light
    }), import_react6.default.createElement("div", null, import_react6.default.createElement("span", {
      className: "button-label"
    }, provider.meta.name)));
  }))))) : null;
};
var ConnectDialog$1 = ConnectDialog;
export {
  Connect2ICContext,
  Connect2ICProvider,
  ConnectButton$1 as ConnectButton,
  ConnectDialog$1 as ConnectDialog,
  useBalance,
  useCanister,
  useClient,
  useConnect,
  useDialog,
  useProviders,
  useSignMessage,
  useTransfer,
  useWallet
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@connect2ic_react.js.map
