import {
  assign,
  createMachine,
  forwardTo,
  interpret
} from "./chunk-RMBEYMPO.js";
import {
  Actor,
  HttpAgent
} from "./chunk-YCHRVTB5.js";
import "./chunk-PACUOSRF.js";
import "./chunk-JBATXUZM.js";
import "./chunk-HM4MQYWN.js";

// ../../node_modules/event-e3/event-e3.js
function EventEmitter3(obj) {
  (obj || this)._callbacks = /* @__PURE__ */ Object.create(null);
  if (obj) {
    return Object.assign(obj, EventEmitter3.prototype);
  }
}
EventEmitter3.prototype.on = function(eventName, fn) {
  (this._callbacks[eventName] = this._callbacks[eventName] || []).push(fn);
};
EventEmitter3.prototype.once = function(eventName, fn) {
  const once = (data) => {
    this.off(eventName, once);
    fn(data);
  };
  once.fn = fn;
  this.on(eventName, once);
};
EventEmitter3.prototype.off = function(eventName, fn) {
  if (!eventName) {
    this._callbacks = /* @__PURE__ */ Object.create(null);
    return;
  }
  const callbacks = this._callbacks[eventName];
  if (!callbacks) {
    return;
  }
  if (!fn) {
    delete this._callbacks[eventName];
    return;
  }
  const index = callbacks.findIndex(function(cb) {
    return cb === fn || cb.fn === fn;
  });
  if (index > -1) {
    if (callbacks.length === 1) {
      delete this._callbacks[eventName];
    } else {
      callbacks.splice(index, 1);
    }
  }
};
EventEmitter3.prototype.emit = function(eventName, data) {
  const callbacks = this._callbacks[eventName];
  if (!callbacks) {
    return;
  }
  const frozenCallbacks = Array.from(callbacks);
  frozenCallbacks.forEach((callback) => {
    callback(data);
  });
};
EventEmitter3.prototype.listeners = function(eventName) {
  return this._callbacks[eventName] || [];
};
EventEmitter3.prototype.hasListeners = function(eventName) {
  return Boolean(this.listeners(eventName).length);
};
EventEmitter3.prototype.eventNames = function() {
  return Reflect.ownKeys(this._callbacks);
};
EventEmitter3.prototype.eventNamesStrings = function() {
  return Object.keys(this._callbacks);
};
var event_e3_default = EventEmitter3;

// ../../node_modules/@connect2ic/core/dist/connect2ic-core.esm.js
var authStates = {
  id: "auth",
  initial: "initializing",
  schema: {
    context: {},
    events: {}
  },
  states: {
    initializing: {
      on: {
        DONE: {
          target: "idle",
          actions: assign((context, event) => ({
            providers: event.data.providers
          }))
        },
        DONE_AND_CONNECTED: {
          target: "connected",
          actions: [assign((context, event) => ({
            providers: event.data.providers,
            activeProvider: event.data.activeProvider,
            principal: event.data.principal
          }))]
        }
      },
      invoke: {
        id: "init",
        src: (context, event) => async (callback, onReceive) => {
          const {
            providers
          } = context;
          await Promise.allSettled(providers.map((p) => p.init()));
          let connectedProviders = providers.map((p) => new Promise(async (resolve, reject) => {
            const isConnected = await p.isConnected();
            isConnected ? resolve(p) : reject();
          }));
          Promise.any(connectedProviders).then((connectedProvider) => {
            callback({
              type: "DONE_AND_CONNECTED",
              data: {
                providers,
                activeProvider: connectedProvider,
                principal: connectedProvider.principal
              }
            });
          }).catch((e) => {
            callback({
              type: "DONE",
              data: {
                providers
              }
            });
          });
        }
      },
      exit: ["onInit"]
    },
    idle: {
      invoke: {
        id: "connectService",
        autoForward: true,
        src: (context, _event) => (callback, onReceive) => {
          onReceive(async (e) => {
            const provider = context.providers.find((p) => p.meta.id === e.data.provider);
            if (e.type === "CONNECT") {
              const connected = await provider.connect();
              if (connected) {
                callback({
                  type: "CONNECT_DONE",
                  // TODO: fix?
                  data: {
                    activeProvider: provider,
                    principal: provider.principal
                  }
                });
              } else {
                callback({
                  type: "ERROR",
                  data: {
                    error: e
                  }
                });
              }
            }
          });
        }
      },
      on: {
        CONNECT: {
          actions: forwardTo("connectService")
        },
        CONNECT_DONE: {
          target: "connected",
          actions: [assign((context, event) => ({
            activeProvider: event.data.activeProvider,
            principal: event.data.principal
          }))]
        },
        ERROR: {
          // actions: assign((context, event) => {
          //   return ({
          //     provider: event.data.provider,
          //     principal: event.data.principal,
          //   })
          // }),
        }
      }
    },
    connected: {
      entry: ["onConnect"],
      invoke: {
        id: "actorService",
        src: "actorService",
        autoForward: true
      },
      on: {
        DISCONNECT: {
          target: "disconnecting"
          // TODO: pass provider?
        },
        SAVE_ACTOR: {
          actions: assign((context, event) => ({
            actors: {
              ...context.actors,
              [event.data.canisterName]: event.data.actor
            }
          }))
        }
      }
    },
    disconnecting: {
      invoke: {
        id: "disconnect",
        src: (context, event) => async () => {
          var _context$activeProvid;
          await ((_context$activeProvid = context.activeProvider) === null || _context$activeProvid === void 0 ? void 0 : _context$activeProvid.disconnect());
        },
        onDone: {
          target: "idle",
          // TODO: empty context
          actions: [assign((context, event) => ({
            activeProvider: void 0,
            actors: {},
            principal: void 0
          })), "onDisconnect"]
        },
        onError: {
          target: "connected",
          actions: []
        }
      }
    }
  }
};
var createClient = (_ref) => {
  let {
    canisters = {},
    providers: p = [],
    globalProviderConfig = {}
  } = _ref;
  const config = {
    dev: true,
    autoConnect: true,
    host: window.location.origin,
    whitelist: Object.values(canisters).map((canister) => canister.canisterId),
    ...globalProviderConfig
  };
  const providers = typeof p === "function" ? p(config) : p;
  providers.forEach((p2) => p2.config = config);
  const anonymousActors = Object.entries(canisters).map((_ref2) => {
    let [canisterName, val] = _ref2;
    const {
      canisterId,
      idlFactory
    } = val;
    const agent = new HttpAgent({
      host: config.host
    });
    if (config.dev) {
      agent.fetchRootKey().catch((err) => {
        console.warn("Unable to fetch root key. Check to ensure that your local replica is running");
        console.error(err);
      });
    }
    const actor = Actor.createActor(idlFactory, {
      agent,
      canisterId
    });
    return {
      actor,
      canisterName,
      idlFactory,
      canisterId
    };
  }).reduce((acc, _ref3) => {
    let {
      canisterName,
      actor
    } = _ref3;
    return {
      ...acc,
      [canisterName]: actor
    };
  }, {});
  const emitter = new event_e3_default();
  const rootMachine = createMachine({
    id: "root",
    initial: "idle",
    context: {
      ...config,
      providers,
      anonymousActors,
      canisters,
      actors: {},
      principal: void 0,
      activeProvider: void 0
    },
    schema: {
      context: {},
      events: {}
    },
    states: {
      idle: {
        ...authStates
      }
    }
  }, {
    services: {
      actorService: (context, _event) => (callback, onReceive) => {
        onReceive(async (e) => {
          if (e.type === "CREATE_ACTOR") {
            const actor = await context.activeProvider.createActor(e.data.canisterId, e.data.idlFactory);
            callback({
              type: "SAVE_ACTOR",
              data: {
                actor,
                canisterName: e.data.canisterName
              }
            });
          }
        });
        Object.entries(context.canisters).forEach(async (_ref4) => {
          let [canisterName, val] = _ref4;
          const {
            canisterId,
            idlFactory
          } = val;
          const actor = await context.activeProvider.createActor(canisterId, idlFactory);
          callback({
            type: "SAVE_ACTOR",
            data: {
              actor,
              canisterName
            }
          });
        });
      }
    },
    actions: {
      onDisconnect: (context, event) => {
        emitter.emit("disconnect");
      },
      onInit: (context, event) => {
        emitter.emit("init");
      },
      onConnect: (context, event) => {
        emitter.emit("connect", event.data);
      }
    }
  });
  const service = interpret(rootMachine, {
    devTools: true
  });
  service.start();
  return {
    _service: service,
    on: (evt, fn) => {
      emitter.on(evt, fn);
      return () => emitter.off(evt, fn);
    },
    subscribe: (fn) => {
      const sub = service.subscribe(fn);
      return sub.unsubscribe;
    },
    connect: (provider) => {
      service.send({
        type: "CONNECT",
        data: {
          provider
        }
      });
    },
    disconnect: () => {
      service.send({
        type: "DISCONNECT"
      });
    },
    get providers() {
      return service.state.context.providers;
    },
    get activeProvider() {
      return service.state.context.activeProvider;
    },
    get principal() {
      return service.state.context.principal;
    },
    get actors() {
      return service.state.context.actors;
    },
    get anonymousActors() {
      return service.state.context.anonymousActors;
    },
    get status() {
      return service.state.value.idle;
    },
    get config() {
      return config;
    }
  };
};
export {
  createClient
};
//# sourceMappingURL=@connect2ic_core.js.map
