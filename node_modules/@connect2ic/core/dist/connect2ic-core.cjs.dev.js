'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var xstate = require('xstate');
var agent = require('@dfinity/agent');
var Emitter = require('event-e3');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var Emitter__default = /*#__PURE__*/_interopDefault(Emitter);

const authStates = {
  id: "auth",
  initial: "initializing",
  schema: {
    context: {},
    events: {}
  },
  states: {
    initializing: {
      on: {
        DONE: {
          target: "idle",
          actions: xstate.assign((context, event) => ({
            providers: event.data.providers
          }))
        },
        DONE_AND_CONNECTED: {
          target: "connected",
          actions: [xstate.assign((context, event) => ({
            providers: event.data.providers,
            activeProvider: event.data.activeProvider,
            principal: event.data.principal
          }))]
        }
      },
      invoke: {
        id: "init",
        src: (context, event) => async (callback, onReceive) => {
          // TODO: clean up
          const {
            providers
          } = context;
          await Promise.allSettled(providers.map(p => p.init()));
          let connectedProviders = providers.map(p => new Promise(async (resolve, reject) => {
            const isConnected = await p.isConnected();
            isConnected ? resolve(p) : reject();
          })); // TODO: split into 2?

          Promise.any(connectedProviders).then(connectedProvider => {
            callback({
              type: "DONE_AND_CONNECTED",
              data: {
                providers,
                activeProvider: connectedProvider,
                principal: connectedProvider.principal
              }
            });
          }).catch(e => {
            callback({
              type: "DONE",
              data: {
                providers
              }
            });
          });
        }
      },
      exit: ["onInit"]
    },
    idle: {
      invoke: {
        id: "connectService",
        autoForward: true,
        src: (context, _event) => (callback, onReceive) => {
          onReceive(async e => {
            // TODO: Handle cancellation with AbortController?
            const provider = context.providers.find(p => p.meta.id === e.data.provider);

            if (e.type === "CONNECT") {
              const connected = await provider.connect();

              if (connected) {
                callback({
                  type: "CONNECT_DONE",
                  // TODO: fix?
                  data: {
                    activeProvider: provider,
                    principal: provider.principal
                  }
                });
              } else {
                callback({
                  type: "ERROR",
                  data: {
                    error: e
                  }
                });
              }
            }
          });
        }
      },
      on: {
        CONNECT: {
          actions: xstate.forwardTo("connectService")
        },
        CONNECT_DONE: {
          target: "connected",
          actions: [xstate.assign((context, event) => ({
            activeProvider: event.data.activeProvider,
            principal: event.data.principal
          }))]
        },
        ERROR: {// actions: assign((context, event) => {
          //   return ({
          //     provider: event.data.provider,
          //     principal: event.data.principal,
          //   })
          // }),
        }
      }
    },
    connected: {
      entry: ["onConnect"],
      invoke: {
        id: "actorService",
        src: "actorService",
        autoForward: true
      },
      on: {
        DISCONNECT: {
          target: "disconnecting" // TODO: pass provider?

        },
        SAVE_ACTOR: {
          actions: xstate.assign((context, event) => ({
            actors: { ...context.actors,
              [event.data.canisterName]: event.data.actor
            }
          }))
        }
      }
    },
    disconnecting: {
      invoke: {
        id: "disconnect",
        src: (context, event) => async () => {
          var _context$activeProvid;

          await ((_context$activeProvid = context.activeProvider) === null || _context$activeProvid === void 0 ? void 0 : _context$activeProvid.disconnect());
        },
        onDone: {
          target: "idle",
          // TODO: empty context
          actions: [xstate.assign((context, event) => ({
            activeProvider: undefined,
            actors: {},
            principal: undefined
          })), "onDisconnect"]
        },
        onError: {
          target: "connected",
          actions: []
        }
      }
    }
  }
};

const createClient = _ref => {
  let {
    canisters = {},
    providers: p = [],
    globalProviderConfig = {}
  } = _ref;
  const config = {
    dev: true,
    autoConnect: true,
    host: window.location.origin,
    whitelist: Object.values(canisters).map(canister => canister.canisterId),
    ...globalProviderConfig
  };
  const providers = typeof p === "function" ? p(config) : p;
  providers.forEach(p => p.config = config);
  const anonymousActors = Object.entries(canisters).map(_ref2 => {
    let [canisterName, val] = _ref2;
    const {
      canisterId,
      idlFactory
    } = val;
    const agent$1 = new agent.HttpAgent({
      host: config.host
    }); // Fetch root key for certificate validation during development

    if (config.dev) {
      agent$1.fetchRootKey().catch(err => {
        console.warn("Unable to fetch root key. Check to ensure that your local replica is running");
        console.error(err);
      });
    }

    const actor = agent.Actor.createActor(idlFactory, {
      agent: agent$1,
      canisterId
    });
    return {
      actor,
      canisterName,
      idlFactory,
      canisterId
    };
  }).reduce((acc, _ref3) => {
    let {
      canisterName,
      actor
    } = _ref3;
    return { ...acc,
      [canisterName]: actor
    };
  }, {});
  const emitter = new Emitter__default["default"]();
  const rootMachine = xstate.createMachine({
    id: "root",
    initial: "idle",
    context: { ...config,
      providers,
      anonymousActors,
      canisters,
      actors: {},
      principal: undefined,
      activeProvider: undefined
    },
    schema: {
      context: {},
      events: {}
    },
    states: {
      idle: { ...authStates
      }
    }
  }, {
    services: {
      actorService: (context, _event) => (callback, onReceive) => {
        onReceive(async e => {
          if (e.type === "CREATE_ACTOR") {
            const actor = await context.activeProvider.createActor(e.data.canisterId, e.data.idlFactory);
            callback({
              type: "SAVE_ACTOR",
              data: {
                actor,
                canisterName: e.data.canisterName
              }
            });
          }
        });
        Object.entries(context.canisters).forEach(async _ref4 => {
          let [canisterName, val] = _ref4;
          const {
            canisterId,
            idlFactory
          } = val;
          const actor = await context.activeProvider.createActor(canisterId, idlFactory);
          callback({
            type: "SAVE_ACTOR",
            data: {
              actor,
              canisterName
            }
          });
        });
      }
    },
    actions: {
      onDisconnect: (context, event) => {
        emitter.emit("disconnect");
      },
      onInit: (context, event) => {
        emitter.emit("init");
      },
      onConnect: (context, event) => {
        emitter.emit("connect", event.data);
      }
    }
  });
  const service = xstate.interpret(rootMachine, {
    devTools: true
  });
  service.start();
  return {
    _service: service,
    on: (evt, fn) => {
      emitter.on(evt, fn);
      return () => emitter.off(evt, fn);
    },
    subscribe: fn => {
      const sub = service.subscribe(fn);
      return sub.unsubscribe;
    },
    connect: provider => {
      service.send({
        type: "CONNECT",
        data: {
          provider
        }
      });
    },
    disconnect: () => {
      service.send({
        type: "DISCONNECT"
      });
    },

    get providers() {
      return service.state.context.providers;
    },

    get activeProvider() {
      return service.state.context.activeProvider;
    },

    get principal() {
      return service.state.context.principal;
    },

    get actors() {
      return service.state.context.actors;
    },

    get anonymousActors() {
      return service.state.context.anonymousActors;
    },

    get status() {
      return service.state.value.idle;
    },

    get config() {
      return config;
    }

  };
};

exports.createClient = createClient;
