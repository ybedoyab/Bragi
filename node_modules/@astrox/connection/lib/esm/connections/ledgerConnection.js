import { BaseConnection, executeWithLogging, _createActor } from './baseConnection';
import ledger_idl from '../canisters/ledger.idl';
import { fromSubAccountId } from '../utils/converter';
import { LEDGER_CANISTER_ID } from '../utils/constants';
export class LedgerConnection extends BaseConnection {
    constructor(identity, delegationIdentity, actor, agent, legerCanisterId) {
        super(identity, delegationIdentity, legerCanisterId !== null && legerCanisterId !== void 0 ? legerCanisterId : LEDGER_CANISTER_ID, ledger_idl, actor, agent);
        this.identity = identity;
        this.delegationIdentity = delegationIdentity;
        this.actor = actor;
        this.agent = agent;
    }
    /**
     * create connection
     * @param identity
     * @param delegationIdentity
     * @param legerCanisterId
     * @param actor
     * @param agent
     * @function createConnection
     * @returns {LedgerConnection}
     */
    static createConnection(identity, delegationIdentity, legerCanisterId, actor, agent) {
        return new LedgerConnection(identity, delegationIdentity, actor, agent, legerCanisterId !== null && legerCanisterId !== void 0 ? legerCanisterId : LEDGER_CANISTER_ID);
    }
    /**
     * create Actor with DelegationIdentity
     * @param delegationIdentity
     * @param canisterId
     * @param ledgerCanisterId
     * @param host
     * @function {function name}
     * @returns {type} {description}
     */
    static async createActor(delegationIdentity, ledgerCanisterId, host) {
        const actor = await _createActor(ledger_idl, ledgerCanisterId !== null && ledgerCanisterId !== void 0 ? ledgerCanisterId : LEDGER_CANISTER_ID, delegationIdentity, host);
        return actor;
    }
    static async createConnectionWithII(identity, delegationIdentity, legerCanisterId) {
        const actorResult = await LedgerConnection.createActor(delegationIdentity);
        return LedgerConnection.createConnection(identity, delegationIdentity, legerCanisterId !== null && legerCanisterId !== void 0 ? legerCanisterId : LEDGER_CANISTER_ID, actorResult.actor, actorResult.agent);
    }
    static async actorGetBalance(actor, account) {
        const response = await executeWithLogging(() => actor.account_balance_dfx({ account }));
        return response.e8s;
    }
    static async actorSend(actor, { to, amount, sendOpts, }) {
        const response = await executeWithLogging(() => {
            var _a, _b, _c;
            const defaultFee = BigInt(10000);
            const defaultMemo = BigInt(Math.floor(Math.random() * 10000));
            const subAccount = (sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.from_subaccount) === undefined
                ? []
                : Array.from([fromSubAccountId(sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.from_subaccount)]);
            const createAtTime = (sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.created_at_time) === undefined
                ? []
                : Array.from([
                    {
                        timestamp_nanos: BigInt((_a = sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.created_at_time) === null || _a === void 0 ? void 0 : _a.getTime()),
                    },
                ]);
            const sendArgs = {
                to: to,
                fee: {
                    e8s: (_b = sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.fee) !== null && _b !== void 0 ? _b : defaultFee,
                },
                amount: { e8s: amount },
                memo: (_c = sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.memo) !== null && _c !== void 0 ? _c : defaultMemo,
                from_subaccount: subAccount,
                created_at_time: createAtTime,
            };
            return actor.send_dfx(sendArgs);
        });
        return response;
    }
    /**
     * get NNS Actor, used internally
     * @param canisterId
     * @param ledgerCanisterId
     * @function {function name}
     * @returns {type} {description}
     */
    async getLedgerActor(ledgerCanisterId) {
        const actor = await this._getActor(ledgerCanisterId !== null && ledgerCanisterId !== void 0 ? ledgerCanisterId : LEDGER_CANISTER_ID, ledger_idl);
        return actor;
    }
    async getBalance(account) {
        const actor = await this.getLedgerActor();
        const response = await executeWithLogging(() => actor.account_balance_dfx({ account }));
        return response.e8s;
    }
    async send({ to, amount, sendOpts, }) {
        const actor = await this.getLedgerActor();
        const response = await executeWithLogging(() => {
            var _a, _b, _c;
            const defaultFee = BigInt(10000);
            const defaultMemo = BigInt(Math.floor(Math.random() * 10000));
            const subAccount = (sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.from_subaccount) === undefined
                ? []
                : Array.from([fromSubAccountId(sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.from_subaccount)]);
            const createAtTime = (sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.created_at_time) === undefined
                ? []
                : Array.from([
                    {
                        timestamp_nanos: BigInt((_a = sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.created_at_time) === null || _a === void 0 ? void 0 : _a.getTime()),
                    },
                ]);
            const sendArgs = {
                to: to,
                fee: {
                    e8s: (_b = sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.fee) !== null && _b !== void 0 ? _b : defaultFee,
                },
                amount: { e8s: amount },
                memo: (_c = sendOpts === null || sendOpts === void 0 ? void 0 : sendOpts.memo) !== null && _c !== void 0 ? _c : defaultMemo,
                from_subaccount: subAccount,
                created_at_time: createAtTime,
            };
            return actor.send_dfx(sendArgs);
        });
        return response;
    }
}
// export const requestNNSDelegation = async (
//   identity: SignIdentity,
// ): Promise<DelegationIdentity> => {
//   const tenMinutesInMsec = 10 * 1000 * 60;
//   const date = new Date(Date.now() + tenMinutesInMsec);
//   return requestDelegation(identity, { canisterId, date });
// };
//# sourceMappingURL=ledgerConnection.js.map