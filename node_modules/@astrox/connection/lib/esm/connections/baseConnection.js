import { Actor, HttpAgent, } from '@dfinity/agent';
import { Delegation, DelegationChain, DelegationIdentity, Ed25519KeyIdentity, } from '@dfinity/identity';
import { Principal } from '@dfinity/principal';
export function createConnection(identity, delegationIdentity, canisterId, interfaceFactory, actor, agent) {
    return new BaseConnection(identity, delegationIdentity, canisterId, interfaceFactory, actor, agent);
}
export const requestDelegation = async (identity, { canisterId, date }) => {
    const sessionKey = Ed25519KeyIdentity.generate();
    const chain = await DelegationChain.create(identity, sessionKey.getPublicKey(), date || new Date(Date.parse('2100-01-01')), {
        targets: canisterId != undefined ? [Principal.fromText(canisterId)] : undefined,
    });
    return DelegationIdentity.fromDelegation(sessionKey, chain);
};
export async function _createActor(interfaceFactory, canisterId, identity, host) {
    const agent = new HttpAgent({ identity, host });
    // Only fetch the root key when we're not in prod
    if (process.env.II_ENV === 'development') {
        await agent.fetchRootKey();
    }
    const actor = Actor.createActor(interfaceFactory, {
        agent,
        canisterId,
    });
    return { actor, agent };
}
export class BaseConnection {
    constructor(identity, delegationIdentity, canisterId, interfaceFactory, actor, agent) {
        this.identity = identity;
        this.delegationIdentity = delegationIdentity;
        this.canisterId = canisterId;
        this.interfaceFactory = interfaceFactory;
        this.actor = actor;
        this.agent = agent;
    }
    async getActor() {
        throw new Error('Method not implemented.');
    }
    async _getActor(canisterId, interfaceFactory, date) {
        var _a, _b;
        if (this.delegationIdentity) {
            for (const { delegation } of this.delegationIdentity.getDelegation().delegations) {
                // prettier-ignore
                if (+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now()) {
                    this.actor = undefined;
                    break;
                }
            }
        }
        if (this.actor === undefined) {
            // Create our actor with a DelegationIdentity to avoid re-prompting auth
            this.delegationIdentity = await requestDelegation(this.identity, {
                canisterId: (_a = this.canisterId) !== null && _a !== void 0 ? _a : canisterId,
                date: date !== null && date !== void 0 ? date : undefined,
            });
            this.actor = (await _createActor(interfaceFactory, (_b = this.canisterId) !== null && _b !== void 0 ? _b : canisterId, this.delegationIdentity)).actor;
        }
        return this.actor;
    }
}
export async function handleDelegation(message, key) {
    const delegations = message.delegations.map(signedDelegation => {
        return {
            delegation: new Delegation(signedDelegation.delegation.pubkey, signedDelegation.delegation.expiration, signedDelegation.delegation.targets),
            signature: signedDelegation.signature.buffer,
        };
    });
    const delegationChain = DelegationChain.fromDelegations(delegations, message.userPublicKey.buffer);
    return {
        delegationChain,
        delegationIdentity: DelegationIdentity.fromDelegation(key, delegationChain),
    };
}
export const executeWithLogging = async (func) => {
    try {
        return await func();
    }
    catch (e) {
        console.log(e);
        throw e;
    }
};
//# sourceMappingURL=baseConnection.js.map