"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeWithLogging = exports.handleDelegation = exports.BaseConnection = exports._createActor = exports.requestDelegation = exports.createConnection = void 0;
const agent_1 = require("@dfinity/agent");
const identity_1 = require("@dfinity/identity");
const principal_1 = require("@dfinity/principal");
function createConnection(identity, delegationIdentity, canisterId, interfaceFactory, actor, agent) {
    return new BaseConnection(identity, delegationIdentity, canisterId, interfaceFactory, actor, agent);
}
exports.createConnection = createConnection;
exports.requestDelegation = async (identity, { canisterId, date }) => {
    const sessionKey = identity_1.Ed25519KeyIdentity.generate();
    const chain = await identity_1.DelegationChain.create(identity, sessionKey.getPublicKey(), date || new Date(Date.parse('2100-01-01')), {
        targets: canisterId != undefined ? [principal_1.Principal.fromText(canisterId)] : undefined,
    });
    return identity_1.DelegationIdentity.fromDelegation(sessionKey, chain);
};
async function _createActor(interfaceFactory, canisterId, identity, host) {
    const agent = new agent_1.HttpAgent({ identity, host });
    // Only fetch the root key when we're not in prod
    if (process.env.II_ENV === 'development') {
        await agent.fetchRootKey();
    }
    const actor = agent_1.Actor.createActor(interfaceFactory, {
        agent,
        canisterId,
    });
    return { actor, agent };
}
exports._createActor = _createActor;
class BaseConnection {
    constructor(identity, delegationIdentity, canisterId, interfaceFactory, actor, agent) {
        this.identity = identity;
        this.delegationIdentity = delegationIdentity;
        this.canisterId = canisterId;
        this.interfaceFactory = interfaceFactory;
        this.actor = actor;
        this.agent = agent;
    }
    async getActor() {
        throw new Error('Method not implemented.');
    }
    async _getActor(canisterId, interfaceFactory, date) {
        var _a, _b;
        if (this.delegationIdentity) {
            for (const { delegation } of this.delegationIdentity.getDelegation().delegations) {
                // prettier-ignore
                if (+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now()) {
                    this.actor = undefined;
                    break;
                }
            }
        }
        if (this.actor === undefined) {
            // Create our actor with a DelegationIdentity to avoid re-prompting auth
            this.delegationIdentity = await exports.requestDelegation(this.identity, {
                canisterId: (_a = this.canisterId) !== null && _a !== void 0 ? _a : canisterId,
                date: date !== null && date !== void 0 ? date : undefined,
            });
            this.actor = (await _createActor(interfaceFactory, (_b = this.canisterId) !== null && _b !== void 0 ? _b : canisterId, this.delegationIdentity)).actor;
        }
        return this.actor;
    }
}
exports.BaseConnection = BaseConnection;
async function handleDelegation(message, key) {
    const delegations = message.delegations.map(signedDelegation => {
        return {
            delegation: new identity_1.Delegation(signedDelegation.delegation.pubkey, signedDelegation.delegation.expiration, signedDelegation.delegation.targets),
            signature: signedDelegation.signature.buffer,
        };
    });
    const delegationChain = identity_1.DelegationChain.fromDelegations(delegations, message.userPublicKey.buffer);
    return {
        delegationChain,
        delegationIdentity: identity_1.DelegationIdentity.fromDelegation(key, delegationChain),
    };
}
exports.handleDelegation = handleDelegation;
exports.executeWithLogging = async (func) => {
    try {
        return await func();
    }
    catch (e) {
        console.log(e);
        throw e;
    }
};
//# sourceMappingURL=baseConnection.js.map