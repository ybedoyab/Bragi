"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAddressType = exports.AddressType = exports.validateCanisterId = exports.validatePrincipalId = exports.validateAccountId = exports.balanceToString = exports.balanceFromString = exports.parseBalance = exports.formatAssetBySymbol = exports.getDecimalFromSymbol = exports.TokenSymbol = exports.E8S_PER_ICP = exports.calculateCrc32 = exports.stringToAccountIdentifier = exports.principalToSubAccount = exports.principalToAccountIdentifier = exports.accountIdentifierFromBytes = exports.accountIdentifierToBytes = exports.fromSubAccountId = exports.toSubAccountId = exports.asciiStringToByteArray = exports.numberToArrayBuffer = exports.arrayBufferToNumber = exports.arrayOfNumberToArrayBuffer = exports.arrayOfNumberToUint8Array = exports.arrayBufferToArrayOfNumber = exports.bigIntToUint8Array = exports.uint8ArrayToBigInt = void 0;
/* eslint-disable no-useless-catch */
const principal_1 = require("@dfinity/principal");
const js_sha256_1 = require("js-sha256");
const buffer_1 = require("buffer");
const crc_1 = __importDefault(require("crc"));
const constants_1 = require("./constants");
exports.uint8ArrayToBigInt = (array) => {
    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    if (typeof view.getBigUint64 === 'function') {
        return view.getBigUint64(0);
    }
    else {
        const high = BigInt(view.getUint32(0));
        const low = BigInt(view.getUint32(4));
        return (high << BigInt(32)) + low;
    }
};
const TWO_TO_THE_32 = BigInt(1) << BigInt(32);
exports.bigIntToUint8Array = (value) => {
    const array = new Uint8Array(8);
    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    if (typeof view.setBigUint64 === 'function') {
        view.setBigUint64(0, value);
    }
    else {
        view.setUint32(0, Number(value >> BigInt(32)));
        view.setUint32(4, Number(value % TWO_TO_THE_32));
    }
    return array;
};
exports.arrayBufferToArrayOfNumber = (buffer) => {
    const typedArray = new Uint8Array(buffer);
    return Array.from(typedArray);
};
exports.arrayOfNumberToUint8Array = (numbers) => {
    return new Uint8Array(numbers);
};
exports.arrayOfNumberToArrayBuffer = (numbers) => {
    return exports.arrayOfNumberToUint8Array(numbers).buffer;
};
exports.arrayBufferToNumber = (buffer) => {
    const view = new DataView(buffer);
    return view.getUint32(view.byteLength - 4);
};
exports.numberToArrayBuffer = (value, byteLength) => {
    const buffer = new ArrayBuffer(byteLength);
    new DataView(buffer).setUint32(byteLength - 4, value);
    return buffer;
};
exports.asciiStringToByteArray = (text) => {
    return Array.from(text).map(c => c.charCodeAt(0));
};
exports.toSubAccountId = (subAccount) => {
    const bytes = exports.arrayOfNumberToArrayBuffer(subAccount);
    return exports.arrayBufferToNumber(bytes);
};
exports.fromSubAccountId = (subAccountId) => {
    const buffer = exports.numberToArrayBuffer(subAccountId, constants_1.SUB_ACCOUNT_BYTE_LENGTH);
    return exports.arrayBufferToArrayOfNumber(buffer);
};
exports.accountIdentifierToBytes = (accountIdentifier) => {
    return Uint8Array.from(buffer_1.Buffer.from(accountIdentifier, 'hex')).subarray(4);
};
exports.accountIdentifierFromBytes = (accountIdentifier) => {
    return buffer_1.Buffer.from(accountIdentifier).toString('hex');
};
exports.principalToAccountIdentifier = (principal, subAccount) => {
    // Hash (sha224) the principal, the subAccount and some padding
    const padding = exports.asciiStringToByteArray('\x0Aaccount-id');
    const shaObj = js_sha256_1.sha224.create();
    shaObj.update([...padding, ...principal.toUint8Array(), ...(subAccount !== null && subAccount !== void 0 ? subAccount : Array(32).fill(0))]);
    const hash = new Uint8Array(shaObj.array());
    // Prepend the checksum of the hash and convert to a hex string
    const checksum = exports.calculateCrc32(hash);
    const bytes = new Uint8Array([...checksum, ...hash]);
    return toHexString(bytes);
};
exports.principalToSubAccount = (principal) => {
    const bytes = principal.toUint8Array();
    const subAccount = new Uint8Array(32);
    subAccount[0] = bytes.length;
    subAccount.set(bytes, 1);
    return subAccount;
};
exports.stringToAccountIdentifier = (str) => {
    try {
        if (str.length === 64) {
            return str;
        }
        if (str.length === 63) {
            return exports.principalToAccountIdentifier(principal_1.Principal.fromText(str));
        }
        return undefined;
    }
    catch (error) {
        return undefined;
    }
};
const toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
// 4 bytes
exports.calculateCrc32 = (bytes) => {
    const checksumArrayBuf = new ArrayBuffer(4);
    const view = new DataView(checksumArrayBuf);
    view.setUint32(0, crc_1.default.crc32(buffer_1.Buffer.from(bytes)), false);
    return buffer_1.Buffer.from(checksumArrayBuf);
};
exports.E8S_PER_ICP = 100000000;
var TokenSymbol;
(function (TokenSymbol) {
    TokenSymbol["ICP"] = "ICP";
})(TokenSymbol = exports.TokenSymbol || (exports.TokenSymbol = {}));
exports.getDecimalFromSymbol = (sym) => {
    switch (sym) {
        case TokenSymbol.ICP:
            return 8;
        default:
            return 8;
    }
};
exports.formatAssetBySymbol = (_amount, symbol) => {
    const balanceString = exports.balanceToString(_amount, exports.getDecimalFromSymbol(symbol));
    const amount = Number(balanceString.total);
    const tokenMap = [
        {
            ICP: {
                amount: amount,
                balanceString,
                symbol: 'ICP',
            },
        },
    ];
    const found = tokenMap.find((v) => v[symbol] !== undefined);
    return found === null || found === void 0 ? void 0 : found[symbol];
};
exports.parseBalance = (balance) => {
    return (parseInt(balance.value, 10) / 10 ** balance.decimals).toString();
};
exports.balanceFromString = (balance, decimal = 8) => {
    const list = balance.split('.');
    const aboveZero = list[0];
    const aboveZeroBigInt = BigInt(aboveZero) * BigInt(1 * 10 ** decimal);
    let belowZeroBigInt = BigInt(0);
    const belowZero = list[1];
    if (belowZero !== undefined) {
        belowZeroBigInt = BigInt(belowZero.substring(0, decimal).padEnd(decimal, '0'));
    }
    return aboveZeroBigInt + belowZeroBigInt;
};
exports.balanceToString = (balance, decimal = 8) => {
    const balanceString = balance.toString(10);
    const balanceStringLength = balanceString.length;
    let aboveZero = '0';
    let belowZero = '0'.padEnd(decimal, '0');
    if (balanceStringLength > decimal) {
        belowZero = balanceString.substring(balanceStringLength - decimal, balanceStringLength);
        aboveZero = balanceString.substring(0, balanceStringLength - decimal);
    }
    else {
        belowZero = balanceString.padStart(decimal, '0');
    }
    const formatAboveZero = String(aboveZero).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    return { total: aboveZero + '.' + belowZero, aboveZero, belowZero, formatAboveZero };
};
exports.validateAccountId = (text) => text.length === 64 && constants_1.ALPHANUM_REGEX.test(text);
exports.validatePrincipalId = (text) => {
    try {
        return text === principal_1.Principal.fromText(text).toString();
    }
    catch (e) {
        return false;
    }
};
exports.validateCanisterId = (text) => {
    try {
        return text.length <= constants_1.CANISTER_MAX_LENGTH && exports.validatePrincipalId(text);
    }
    catch (e) {
        return false;
    }
};
var AddressType;
(function (AddressType) {
    AddressType["PRINCIPAL"] = "principal";
    AddressType["ACCOUNT"] = "accountId";
    AddressType["CANISTER"] = "canister";
    AddressType["ERC20"] = "erc20";
    AddressType["INVALID"] = "invalid";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
exports.getAddressType = (text) => {
    try {
        if (exports.validateAccountId(text)) {
            return AddressType.ACCOUNT;
        }
        else if (exports.validatePrincipalId(text)) {
            return AddressType.PRINCIPAL;
        }
        else if (exports.validateCanisterId(text)) {
            return AddressType.CANISTER;
        }
        return AddressType.INVALID;
    }
    catch (error) {
        throw error;
    }
};
//# sourceMappingURL=converter.js.map