"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _authClient, _agent, _localLedger, _walletProvider, _signerProvider, _useFrame;
Object.defineProperty(exports, "__esModule", { value: true });
exports.IC = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const agent_1 = require("@dfinity/agent");
const icAuthClient_1 = require("./icAuthClient");
const icStorage_1 = require("./icStorage");
const icWindow_1 = require("./icWindow");
const ledgerConnection_1 = require("../connections/ledgerConnection");
const types_1 = require("../types");
const days = BigInt(1);
const hours = BigInt(24);
const nanoseconds = BigInt(3600000000000);
const WALLET_PROVIDER_DEFAULT = 'https://63k2f-nyaaa-aaaah-aakla-cai.raw.ic0.app';
const WALLET_PROVIDER_ENDPOINT = '#transaction';
const SIGNER_PROVIDER_DEFAULT = 'https://63k2f-nyaaa-aaaah-aakla-cai.raw.ic0.app';
const SIGNER_PROVIDER_ENDPOINT = '#signer';
const FRAME_SETTING = 'height=600, width=800, top=0, right=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no';
const FRAME_SETTING_PAYMENT = 'height=600, width=480, top=0, right=0, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no';
class IC extends icWindow_1.ICWindow {
    constructor(authClient, agent) {
        super();
        _authClient.set(this, void 0);
        _agent.set(this, void 0);
        _localLedger.set(this, void 0);
        _walletProvider.set(this, void 0);
        _signerProvider.set(this, void 0);
        _useFrame.set(this, false); // a local ledger to query balance only
        this.disconnect = async (options = {}) => {
            await this.getAuthClient().logout(options);
        };
        this.queryBalance = async () => {
            var _a;
            if (this.wallet === undefined) {
                throw Error('Wallet address is not found');
            }
            if (__classPrivateFieldGet(this, _localLedger) === undefined) {
                throw Error('Ledger connection failed');
            }
            const result = await ((_a = __classPrivateFieldGet(this, _localLedger)) === null || _a === void 0 ? void 0 : _a.getBalance(this.wallet));
            return result;
        };
        this.handleAuthenticated = async ({ ledgerCanisterId, ledgerHost }) => {
            const actorResult = await ledgerConnection_1.LedgerConnection.createActor(this.getAuthClient().getDelegationIdentity(), ledgerCanisterId, ledgerHost);
            __classPrivateFieldSet(this, _localLedger, ledgerConnection_1.LedgerConnection.createConnection(this.getAuthClient().getInnerKey(), this.getAuthClient().getDelegationIdentity(), ledgerCanisterId, actorResult.actor, __classPrivateFieldGet(this, _agent)));
        };
        this.createActor = (idlFactory, canisterId) => {
            return agent_1.Actor.createActor(idlFactory, {
                agent: __classPrivateFieldGet(this, _agent),
                canisterId,
            });
        };
        // requestTransfer
        this.requestTransfer = async (options) => {
            var _a;
            console.assert(this.wallet !== undefined, 'wallet address is not found');
            const walletProviderUrl = new URL(((_a = options === null || options === void 0 ? void 0 : options.walletProvider) === null || _a === void 0 ? void 0 : _a.toString()) || __classPrivateFieldGet(this, _walletProvider) || WALLET_PROVIDER_DEFAULT);
            walletProviderUrl.hash = WALLET_PROVIDER_ENDPOINT;
            this._openWindow(walletProviderUrl.toString(), 'icWindow', __classPrivateFieldGet(this, _useFrame) ? FRAME_SETTING_PAYMENT : undefined);
            return new Promise((resolve, reject) => {
                this._eventHandler = this._getEventHandler(walletProviderUrl, resolve, reject, options);
                window.addEventListener('message', this._eventHandler);
            });
        };
        this.signMessage = async (options) => {
            var _a;
            console.assert(this.wallet !== undefined, 'wallet address is not found');
            const signerProviderUrl = new URL(((_a = options === null || options === void 0 ? void 0 : options.signerProvider) === null || _a === void 0 ? void 0 : _a.toString()) || __classPrivateFieldGet(this, _signerProvider) || SIGNER_PROVIDER_DEFAULT);
            signerProviderUrl.hash = SIGNER_PROVIDER_ENDPOINT;
            this._openWindow(signerProviderUrl.toString(), 'icWindow', __classPrivateFieldGet(this, _useFrame) ? FRAME_SETTING_PAYMENT : undefined);
            return new Promise((resolve, reject) => {
                this._eventHandler = this._getSignerHandler(signerProviderUrl, resolve, reject, options);
                window.addEventListener('message', this._eventHandler);
            });
        };
        __classPrivateFieldSet(this, _authClient, authClient);
        __classPrivateFieldSet(this, _agent, agent);
        this.injectWindow();
    }
    static async create(config) {
        var _a, _b, _c;
        const authClient = await icAuthClient_1.AuthClient.create(Object.assign(Object.assign({}, config), { idpWindowOption: config.useFrame === true
                ? FRAME_SETTING
                : undefined }));
        const identity = authClient.getIdentity();
        const agent = new agent_1.HttpAgent({ identity });
        const newIC = new this(authClient, agent);
        if (config.dev) {
            await agent.fetchRootKey();
        }
        newIC._setWalletProvider(config === null || config === void 0 ? void 0 : config.walletProviderUrl);
        newIC._setSignerProvider(config === null || config === void 0 ? void 0 : config.signerProviderUrl);
        newIC._setUseFrame(config === null || config === void 0 ? void 0 : config.useFrame);
        if (await newIC.isAuthenticated()) {
            await newIC.handleAuthenticated({
                ledgerCanisterId: (_a = config.ledgerCanisterId) !== null && _a !== void 0 ? _a : 'ryjl3-tyaaa-aaaaa-aaaba-cai',
                ledgerHost: (_b = config.ledgerHost) !== null && _b !== void 0 ? _b : 'https://boundary.ic0.app/',
            });
            await ((_c = config === null || config === void 0 ? void 0 : config.onAuthenticated) === null || _c === void 0 ? void 0 : _c.call(config, newIC));
        }
        return newIC;
    }
    async connect(connectOptions) {
        var _a;
        const provider = (_a = connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.identityProvider) !== null && _a !== void 0 ? _a : icStorage_1.IDENTITY_PROVIDER_DEFAULT;
        await new Promise((resolve, reject) => {
            var _a, _b;
            this.getAuthClient().login({
                identityProvider: provider,
                // Maximum authorization expiration is 8 days
                maxTimeToLive: (_a = connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.maxTimeToLive) !== null && _a !== void 0 ? _a : days * hours * nanoseconds,
                permissions: (_b = connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.permissions) !== null && _b !== void 0 ? _b : [types_1.PermissionsType.identity],
                onSuccess: async () => {
                    var _a, _b, _c, _d;
                    await this.handleAuthenticated({
                        ledgerCanisterId: connectOptions.ledgerCanisterId,
                        ledgerHost: (_a = connectOptions.ledgerHost) !== null && _a !== void 0 ? _a : 'https://boundary.ic0.app/',
                    });
                    (_c = (await ((_b = connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.onSuccess) === null || _b === void 0 ? void 0 : _b.call(connectOptions)))) !== null && _c !== void 0 ? _c : (await ((_d = connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.onAuthenticated) === null || _d === void 0 ? void 0 : _d.call(connectOptions, this)));
                    resolve(undefined);
                },
                onError: this.handleError,
            });
        });
        return this;
    }
    async isAuthenticated() {
        const result = await __classPrivateFieldGet(this, _authClient).isAuthenticated();
        return result;
    }
    get identity() {
        return __classPrivateFieldGet(this, _authClient).getIdentity();
    }
    get principal() {
        return this.identity.getPrincipal();
    }
    get wallet() {
        return __classPrivateFieldGet(this, _authClient).wallet;
    }
    _setWalletProvider(provider) {
        __classPrivateFieldSet(this, _walletProvider, provider);
    }
    _setSignerProvider(provider) {
        __classPrivateFieldSet(this, _signerProvider, provider);
    }
    _setUseFrame(useFrame) {
        __classPrivateFieldSet(this, _useFrame, useFrame);
    }
    getAuthClient() {
        return __classPrivateFieldGet(this, _authClient);
    }
    injectWindow() {
        if (window.ic !== undefined) {
            window.ic.astrox = this;
        }
        else {
            window.ic = { astrox: this };
        }
    }
    handleError(error) {
        throw new Error(error);
    }
    _getSignerHandler(walletProviderUrl, resolve, reject, options) {
        return async (event) => {
            var _a, _b, _c, _d, _e;
            if (event.origin !== walletProviderUrl.origin) {
                return;
            }
            const message = event.data;
            switch (message.kind) {
                case types_1.SignerMessageKind.ready: {
                    // IDP is ready. Send a message to request authorization.
                    const request = {
                        kind: types_1.SignerMessageKind.client,
                        from: (_a = options.from) !== null && _a !== void 0 ? _a : this.wallet,
                        message: options.message,
                        maxTimeout: (_b = options.maxTimeout) !== null && _b !== void 0 ? _b : 90,
                        successTimeout: (_c = options.successTimeout) !== null && _c !== void 0 ? _c : 10,
                    };
                    (_d = this._window) === null || _d === void 0 ? void 0 : _d.postMessage(request, walletProviderUrl.origin);
                    break;
                }
                case types_1.SignerMessageKind.success:
                    // Create the delegation chain and store it.
                    try {
                        resolve(this._handleSuccess(message, options.onSuccess, (_e = options.successTimeout) !== null && _e !== void 0 ? _e : 10));
                    }
                    catch (err) {
                        reject(this._handleFailure(err.message, options.onError));
                    }
                    break;
                case types_1.SignerMessageKind.fail:
                    reject(this._handleFailure(message.text, options.onError));
                    break;
                default:
                    break;
            }
        };
    }
    _getEventHandler(walletProviderUrl, resolve, reject, options) {
        return async (event) => {
            var _a, _b, _c, _d, _e;
            if (event.origin !== walletProviderUrl.origin) {
                return;
            }
            const message = event.data;
            switch (message.kind) {
                case types_1.TransactionMessageKind.ready: {
                    // IDP is ready. Send a message to request authorization.
                    const request = {
                        kind: types_1.TransactionMessageKind.client,
                        from: (_a = options.from) !== null && _a !== void 0 ? _a : this.wallet,
                        to: options.to,
                        amount: options.amount,
                        sendOpts: options.sendOpts,
                        maxTimeout: (_b = options.maxTimeout) !== null && _b !== void 0 ? _b : 90,
                        successTimeout: (_c = options.successTimeout) !== null && _c !== void 0 ? _c : 10,
                    };
                    (_d = this._window) === null || _d === void 0 ? void 0 : _d.postMessage(request, walletProviderUrl.origin);
                    break;
                }
                case types_1.TransactionMessageKind.success:
                    // Create the delegation chain and store it.
                    try {
                        resolve(this._handleSuccess(message, options.onSuccess, (_e = options.successTimeout) !== null && _e !== void 0 ? _e : 10));
                    }
                    catch (err) {
                        reject(this._handleFailure(err.message, options.onError));
                    }
                    break;
                case types_1.TransactionMessageKind.fail:
                    reject(this._handleFailure(message.text, options.onError));
                    break;
                default:
                    break;
            }
        };
    }
    _handleFailure(errorMessage, onError) {
        this._remove();
        onError === null || onError === void 0 ? void 0 : onError(errorMessage);
        return errorMessage;
    }
    _handleSuccess(value, onSuccess, delay) {
        if (delay) {
            setTimeout(() => this._remove(), delay * 1000);
        }
        else {
            this._remove();
        }
        onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(value);
        return value;
    }
}
exports.IC = IC;
_authClient = new WeakMap(), _agent = new WeakMap(), _localLedger = new WeakMap(), _walletProvider = new WeakMap(), _signerProvider = new WeakMap(), _useFrame = new WeakMap();
//# sourceMappingURL=icConnect.js.map