"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTransactionFromRosseta = exports.getExactTransaction = exports.getICPTransactionsByBlock = exports.getTransactions = exports.getICPTransactions = exports.RosettaTransactionType = exports.RosettaTransactionStatus = exports.MILI_PER_SECOND = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
// import {
//   GetTransactionsResponse,
//   Send,
//   Timestamp,
// } from 'src/frontend/generated/nns-dapp';
const constants_1 = require("../../utils/constants");
const converter_1 = require("../../utils/converter");
const nnsConnection_1 = require("../../connections/nnsConnection");
exports.MILI_PER_SECOND = 1000000;
var RosettaTransactionStatus;
(function (RosettaTransactionStatus) {
    RosettaTransactionStatus["COMPLETED"] = "COMPLETED";
    RosettaTransactionStatus["REVERTED"] = "REVERTED";
    RosettaTransactionStatus["PENDING"] = "PENDING";
})(RosettaTransactionStatus = exports.RosettaTransactionStatus || (exports.RosettaTransactionStatus = {}));
var RosettaTransactionType;
(function (RosettaTransactionType) {
    RosettaTransactionType["TRANSACTION"] = "TRANSACTION";
    RosettaTransactionType["FEE"] = "FEE";
    RosettaTransactionType["RECEIVE"] = "RECEIVE";
    RosettaTransactionType["SEND"] = "SEND";
})(RosettaTransactionType = exports.RosettaTransactionType || (exports.RosettaTransactionType = {}));
const getTransactionInfo = (accountId, rosettaTransaction) => {
    const { operations, metadata: { timestamp: ts, block_height: bh, memo: mm, lockTime: lt }, transaction_identifier: { hash }, } = rosettaTransaction;
    // console.log('------ getting rosetta transaction start  -------');
    // console.log({ rosettaTransaction });
    // console.log('------ getting rosetta transaction end  -------');
    const transaction = {
        type: RosettaTransactionType.SEND,
        details: {
            status: RosettaTransactionStatus.COMPLETED,
            fee: {},
            from: accountId,
        },
    };
    operations.forEach(operation => {
        const value = BigInt(operation.amount.value);
        const { decimals } = operation.amount.currency;
        const amount = converter_1.parseBalance({ value: value.toString(), decimals });
        if (operation.type === RosettaTransactionType.FEE) {
            transaction.details.fee.amount = amount;
            transaction.details.fee.currency = operation.amount.currency;
            return;
        }
        if (value >= 0)
            transaction.details.to = operation.account.address;
        if (value <= 0)
            transaction.details.from = operation.account.address;
        if (transaction.details.status === RosettaTransactionStatus.COMPLETED &&
            operation.status !== RosettaTransactionStatus.COMPLETED)
            transaction.details.status = operation.status;
        transaction.type =
            transaction.details.to === accountId
                ? RosettaTransactionType.RECEIVE
                : RosettaTransactionType.SEND;
        transaction.details.amount = amount;
        transaction.details.currency = operation.amount.currency;
    });
    return Object.assign(Object.assign({}, transaction), { caller: transaction.details.from, hash, timestamp: ts !== undefined ? (BigInt(ts) / BigInt(exports.MILI_PER_SECOND)).toString() : '', block_height: bh !== undefined ? BigInt(bh).toString() : '', memo: mm !== undefined ? BigInt(mm).toString() : '', lockTime: lt !== undefined ? BigInt(lt).toString() : '' });
};
exports.getICPTransactions = async (accountId) => {
    const response = await cross_fetch_1.default(`${constants_1.ROSETTA_URL}/search/transactions`, {
        method: 'POST',
        body: JSON.stringify({
            network_identifier: constants_1.NET_ID,
            account_identifier: {
                address: accountId,
            },
        }),
        headers: {
            'Content-Type': 'application/json',
            'Accept': '*/*',
        },
    });
    if (!response.ok)
        throw Error(`GET_TRANSACTIONS_FAILS: ${response.statusText}`);
    const { transactions, total_count } = await response.json();
    const transactionsInfo = transactions.map(({ transaction }) => getTransactionInfo(accountId, transaction));
    return {
        total: total_count,
        transactions: transactionsInfo,
    };
};
exports.getTransactions = async (localDelegationIdentity, fromAccount) => {
    const result = await nnsConnection_1.NNSConnection.getTransactions({ delegationIdentity: localDelegationIdentity }, { page_size: 10, offset: 0, account_identifier: fromAccount });
    return result;
};
exports.getICPTransactionsByBlock = async (fromAccount, blockHeight) => {
    try {
        const response = await cross_fetch_1.default(`${constants_1.ROSETTA_URL}/block`, {
            method: 'POST',
            body: JSON.stringify({
                network_identifier: constants_1.NET_ID,
                block_identifier: { index: parseInt(blockHeight.toString()) },
            }),
            headers: {
                'Content-Type': 'application/json',
                'Accept': '*/*',
            },
        });
        if (!response.ok)
            throw Error(`GET_TRANSACTIONS_FAILS: ${response.statusText}`);
        const { block } = await response.json();
        const { transactions } = block;
        if (transactions === undefined || block === undefined) {
            return {
                total: transactions.length,
                transactions: [],
            };
        }
        const transactionsInfo = transactions.map((transaction) => getTransactionInfo(fromAccount, transaction));
        return {
            total: transactions.length,
            transactions: transactionsInfo,
        };
    }
    catch (error) {
        throw error;
    }
};
exports.getExactTransaction = (fromAccount, singleResponse, txns) => {
    const { sendArgs } = singleResponse;
    const { amount, created_at_time, memo, to } = sendArgs;
    const { blockHeight } = singleResponse;
    const { transactions } = txns;
    console.log({ singleResponse, txns });
    const found = transactions.find(val => {
        return created_at_time[0] !== undefined
            ? val.timestamp.timestamp_nanos >
                created_at_time[0].timestamp_nanos
            : true &&
                val.block_height === blockHeight &&
                val.memo === memo &&
                JSON.stringify(val.transaction_type[0]) === JSON.stringify({ Send: null }) &&
                val.transfer.Send.amount.e8s === amount.e8s &&
                val.transfer.Send.to === to;
    });
    if (found) {
        const res = {
            hash: '',
            timestamp: (BigInt(found.timestamp.timestamp_nanos) / BigInt(1000000)).toString(),
            type: RosettaTransactionType.SEND,
            details: {
                to,
                from: fromAccount,
                status: RosettaTransactionStatus.COMPLETED,
                amount: amount.e8s.toString(),
                currency: {
                    symbol: converter_1.TokenSymbol.ICP,
                    decimals: 10,
                },
                fee: {
                    amount: found.transfer.Send.fee.e8s.toString(),
                    currency: {
                        symbol: converter_1.TokenSymbol.ICP,
                        decimals: 10,
                    },
                },
            },
            caller: fromAccount,
            block_height: blockHeight.toString(),
            memo: memo.toString(),
            lockTime: '',
        };
        return res;
    }
    return undefined;
};
// use Rosseta API to fetch transaction list, and return
// This API works on mainnet, however not in local testnet
exports.getTransactionFromRosseta = (fromAccount, singleResponse, txns) => {
    const { sendArgs } = singleResponse;
    const { amount, created_at_time, memo, to } = sendArgs;
    const { blockHeight } = singleResponse;
    const { transactions } = txns;
    const found = transactions.find(val => {
        var _a;
        return created_at_time[0] !== undefined
            ? val.timestamp.length < created_at_time[0].timestamp_nanos.toString().length
                ? BigInt(val.timestamp) * BigInt(1000000) >
                    created_at_time[0].timestamp_nanos
                : BigInt(val.timestamp) > created_at_time[0].timestamp_nanos
            : true &&
                BigInt(val.block_height) === blockHeight &&
                BigInt(val.memo) === memo &&
                val.details.to === to &&
                val.details.amount === ((_a = converter_1.formatAssetBySymbol(amount.e8s, val.details.currency.symbol)) === null || _a === void 0 ? void 0 : _a.amount.toString()) &&
                val.caller === fromAccount;
    });
    return found;
};
//# sourceMappingURL=rosseta.js.map